function getAlignment(e){return e.split("-")[1]}function getLengthFromAxis(e){return e==="y"?"height":"width"}function getSide(e){return e.split("-")[0]}function getMainAxisFromPlacement(e){return["top","bottom"].includes(getSide(e))?"x":"y"}function computeCoordsFromPlacement(h,o,r){let{reference:e,floating:n}=h;const a=e.x+e.width/2-n.width/2,i=e.y+e.height/2-n.height/2,s=getMainAxisFromPlacement(o),c=getLengthFromAxis(s),l=e[c]/2-n[c]/2,u=getSide(o),d=s==="x";let t;switch(u){case"top":t={x:a,y:e.y-n.height};break;case"bottom":t={x:a,y:e.y+e.height};break;case"right":t={x:e.x+e.width,y:i};break;case"left":t={x:e.x-n.width,y:i};break;default:t={x:e.x,y:e.y}}switch(getAlignment(o)){case"start":t[s]-=l*(r&&d?-1:1);break;case"end":t[s]+=l*(r&&d?-1:1);break}return t}const computePosition=async(c,o,f)=>{const{placement:l="bottom",strategy:a="absolute",middleware:m=[],platform:n}=f,d=m.filter(Boolean),u=await(n.isRTL==null?void 0:n.isRTL(o));let i=await n.getElementRects({reference:c,floating:o,strategy:a}),{x:e,y:s}=computeCoordsFromPlacement(i,l,u),r=l,t={},h=0;for(let f=0;f<d.length;f++){const{name:p,fn:b}=d[f],{x:g,y:v,data:j,reset:m}=await b({x:e,y:s,initialPlacement:l,placement:r,strategy:a,middlewareData:t,rects:i,platform:n,elements:{reference:c,floating:o}});if(e=g??e,s=v??s,t={...t,[p]:{...t[p],...j}},m&&h<=50){h++,typeof m=="object"&&(m.placement&&(r=m.placement),m.rects&&(i=m.rects===!0?await n.getElementRects({reference:c,floating:o,strategy:a}):m.rects),{x:e,y:s}=computeCoordsFromPlacement(i,r,u)),f=-1;continue}}return{x:e,y:s,placement:r,strategy:a,middlewareData:t}};function evaluate(e,t){return typeof e=="function"?e(t):e}function expandPaddingObject(e){return{top:0,right:0,bottom:0,left:0,...e}}function getSideObjectFromPadding(e){return typeof e!="number"?expandPaddingObject(e):{top:e,right:e,bottom:e,left:e}}function rectToClientRect(e){return{...e,top:e.y,left:e.x,right:e.x+e.width,bottom:e.y+e.height}}async function detectOverflow(m,i){var f;i===void 0&&(i={});const{x:y,y:b,platform:e,rects:d,elements:c,strategy:h}=m,{boundary:p="clippingAncestors",rootBoundary:v="viewport",elementContext:l="floating",altBoundary:j=!1,padding:g=0}=evaluate(i,m),o=getSideObjectFromPadding(g),_=l==="floating"?"reference":"floating",r=c[j?_:l],s=rectToClientRect(await e.getClippingRect({element:((f=await(e.isElement==null?void 0:e.isElement(r)))==null||f)?r:r.contextElement||await(e.getDocumentElement==null?void 0:e.getDocumentElement(c.floating)),boundary:p,rootBoundary:v,strategy:h})),u=l==="floating"?{...d.floating,x:y,y:b}:d.reference,a=await(e.getOffsetParent==null?void 0:e.getOffsetParent(c.floating)),n=await(e.isElement==null?void 0:e.isElement(a))?await(e.getScale==null?void 0:e.getScale(a))||{x:1,y:1}:{x:1,y:1},t=rectToClientRect(e.convertOffsetParentRelativeRectToViewportRelativeRect?await e.convertOffsetParentRelativeRectToViewportRelativeRect({rect:u,offsetParent:a,strategy:h}):u);return{top:(s.top-t.top+o.top)/n.y,bottom:(t.bottom-s.bottom+o.bottom)/n.y,left:(s.left-t.left+o.left)/n.x,right:(t.right-s.right+o.right)/n.x}}const min=Math.min,max=Math.max;function within(e,t,n){return max(e,min(t,n))}const arrow=e=>({name:"arrow",options:e,async fn(v){const{x:M,y:S,placement:_,rects:o,platform:i,elements:A}=v,{element:d,padding:k=0}=evaluate(e,v)||{};if(d==null)return{};const f=getSideObjectFromPadding(k),h={x:M,y:S},t=getMainAxisFromPlacement(_),n=getLengthFromAxis(t),r=await i.getDimensions(d),u=t==="y",E=u?"top":"left",w=u?"bottom":"right",b=u?"clientHeight":"clientWidth",C=o.reference[n]+o.reference[t]-h[t]-o.floating[n],x=h[t]-o.reference[t],m=await(i.getOffsetParent==null?void 0:i.getOffsetParent(d));let a=m?m[b]:0;(!a||!await(i.isElement==null?void 0:i.isElement(m)))&&(a=A.floating[b]||o.floating[n]);const O=C/2-x/2,y=a/2-r[n]/2-1,j=min(f[E],y),g=min(f[w],y),c=j,p=a-r[n]-g,s=a/2-r[n]/2+O,l=within(c,s,p),F=getAlignment(_)!=null&&s!=l&&o.reference[n]/2-(s<c?j:g)-r[n]/2<0,T=F?s<c?c-s:p-s:0;return{[t]:h[t]-T,data:{[t]:l,centerOffset:s-l}}}}),sides=["top","right","bottom","left"],allPlacements=sides.reduce((t,e)=>t.concat(e,e+"-start",e+"-end"),[]),oppositeSideMap={left:"right",right:"left",bottom:"top",top:"bottom"};function getOppositePlacement(e){return e.replace(/left|right|bottom|top/g,e=>oppositeSideMap[e])}function getAlignmentSides(a,n,t){t===void 0&&(t=!1);const s=getAlignment(a),o=getMainAxisFromPlacement(a),i=getLengthFromAxis(o);let e=o==="x"?s===(t?"end":"start")?"right":"left":s==="start"?"bottom":"top";return n.reference[i]>n.floating[i]&&(e=getOppositePlacement(e)),{main:e,cross:getOppositePlacement(e)}}const oppositeAlignmentMap={start:"end",end:"start"};function getOppositeAlignmentPlacement(e){return e.replace(/start|end/g,e=>oppositeAlignmentMap[e])}function getPlacementList(e,n,t){const s=e?[...t.filter(t=>getAlignment(t)===e),...t.filter(t=>getAlignment(t)!==e)]:t.filter(e=>getSide(e)===e);return s.filter(t=>!e||getAlignment(t)===e||(!!n&&getOppositeAlignmentPlacement(t)!==t))}const autoPlacement=function(e){return e===void 0&&(e={}),{name:"autoPlacement",options:e,async fn(o){var p,f,m;const{rects:x,middlewareData:d,placement:l,platform:c,elements:O}=o,{crossAxis:w=!1,alignment:u,allowedPlacements:i=allPlacements,autoAlignment:b=!0,...E}=evaluate(e,o),s=u!==void 0||i===allPlacements?getPlacementList(u||null,b,i):i,r=await detectOverflow(o,E),n=((p=d.autoPlacement)==null?void 0:p.index)||0,t=s[n];if(t==null)return{};const{main:j,cross:y}=getAlignmentSides(t,x,await(c.isRTL==null?void 0:c.isRTL(O.floating)));if(l!==t)return{reset:{placement:s[0]}};const _=[r[getSide(t)],r[j],r[y]],a=[...((f=d.autoPlacement)==null?void 0:f.overflows)||[],{placement:t,overflows:_}],g=s[n+1];if(g)return{data:{index:n+1,overflows:a},reset:{placement:g}};const h=a.map(e=>{const t=getAlignment(e.placement);return[e.placement,t&&w?e.overflows.slice(0,2).reduce((e,t)=>e+t,0):e.overflows[0],e.overflows]}).sort((e,t)=>e[1]-t[1]),C=h.filter(e=>e[2].slice(0,getAlignment(e[0])?2:3).every(e=>e<=0)),v=((m=C[0])==null?void 0:m[0])||h[0][0];return v!==l?{data:{index:n+1,overflows:a},reset:{placement:v}}:{}}}};function getExpandedPlacements(e){const t=getOppositePlacement(e);return[getOppositeAlignmentPlacement(e),t,getOppositeAlignmentPlacement(t)]}function getSideList(s,e,o){const t=["left","right"],n=["right","left"],i=["top","bottom"],a=["bottom","top"];switch(s){case"top":case"bottom":return o?e?n:t:e?t:n;case"left":case"right":return e?i:a;default:return[]}}function getOppositeAxisPlacements(t,s,o,i){const n=getAlignment(t);let e=getSideList(getSide(t),o==="start",i);return n&&(e=e.map(e=>e+"-"+n),s&&(e=e.concat(e.map(getOppositeAlignmentPlacement)))),e}const flip=function(e){return e===void 0&&(e={}),{name:"flip",options:e,async fn(i){var f,c,d,v;const{placement:s,middlewareData:h,rects:C,initialPlacement:t,platform:l,elements:x}=i,{mainAxis:O=!0,crossAxis:w=!0,fallbackPlacements:u,fallbackStrategy:_="bestFit",fallbackAxisSideDirection:m="none",flipAlignment:g=!0,...y}=evaluate(e,i),j=getSide(s),b=getSide(t)===t,r=await(l.isRTL==null?void 0:l.isRTL(x.floating)),p=u||(b||!g?[getOppositePlacement(t)]:getExpandedPlacements(t));!u&&m!=="none"&&p.push(...getOppositeAxisPlacements(t,g,m,r));const E=[t,...p],a=await detectOverflow(i,y),o=[];let n=((f=h.flip)==null?void 0:f.overflows)||[];if(O&&o.push(a[j]),w){const{main:e,cross:t}=getAlignmentSides(s,C,r);o.push(a[e],a[t])}if(n=[...n,{placement:s,overflows:o}],!o.every(e=>e<=0)){const o=(((c=h.flip)==null?void 0:c.index)||0)+1,i=E[o];if(i)return{data:{index:o,overflows:n},reset:{placement:i}};let e=(d=n.filter(e=>e.overflows[0]<=0).sort((e,t)=>e.overflows[1]-t.overflows[1])[0])==null?void 0:d.placement;if(!e)switch(_){case"bestFit":{const t=(v=n.map(e=>[e.placement,e.overflows.filter(e=>e>0).reduce((e,t)=>e+t,0)]).sort((e,t)=>e[1]-t[1])[0])==null?void 0:v[0];t&&(e=t);break}case"initialPlacement":e=t;break}if(s!==e)return{reset:{placement:e}}}return{}}}};function getSideOffsets(e,t){return{top:e.top-t.height,right:e.right-t.width,bottom:e.bottom-t.height,left:e.left-t.width}}function isAnySideFullyClipped(e){return sides.some(t=>e[t]>=0)}const hide=function(e){return e===void 0&&(e={}),{name:"hide",options:e,async fn(t){const{rects:n}=t,{strategy:o="referenceHidden",...s}=evaluate(e,t);switch(o){case"referenceHidden":{const o=await detectOverflow(t,{...s,elementContext:"reference"}),e=getSideOffsets(o,n.reference);return{data:{referenceHiddenOffsets:e,referenceHidden:isAnySideFullyClipped(e)}}}case"escaped":{const o=await detectOverflow(t,{...s,altBoundary:!0}),e=getSideOffsets(o,n.floating);return{data:{escapedOffsets:e,escaped:isAnySideFullyClipped(e)}}}default:return{}}}}};function getBoundingRect(e){const t=min(...e.map(e=>e.left)),n=min(...e.map(e=>e.top)),s=max(...e.map(e=>e.right)),o=max(...e.map(e=>e.bottom));return{x:t,y:n,width:s-t,height:o-n}}function getRectsByLine(s){const n=s.slice().sort((e,t)=>e.y-t.y),e=[];let t=null;for(let o=0;o<n.length;o++){const s=n[o];!t||s.y-t.y>t.height/2?e.push([s]):e[e.length-1].push(s),t=s}return e.map(e=>rectToClientRect(getBoundingRect(e)))}const inline=function(e){return e===void 0&&(e={}),{name:"inline",options:e,async fn(l){const{placement:i,elements:h,rects:o,platform:a,strategy:m}=l,{padding:p=2,x:c,y:r}=evaluate(e,l),d=Array.from(await(a.getClientRects==null?void 0:a.getClientRects(h.reference))||[]),t=getRectsByLine(d),u=rectToClientRect(getBoundingRect(d)),s=getSideObjectFromPadding(p);function f(){if(t.length===2&&t[0].left>t[1].right&&c!=null&&r!=null)return t.find(e=>c>e.left-s.left&&c<e.right+s.right&&r>e.top-s.top&&r<e.bottom+s.bottom)||u;if(t.length>=2){if(getMainAxisFromPlacement(i)==="x"){const e=t[0],n=t[t.length-1],a=getSide(i)==="top",s=e.top,r=n.bottom,o=a?e.left:n.left,c=a?e.right:n.right,l=c-o,d=r-s;return{top:s,bottom:r,left:o,right:c,width:l,height:d,x:o,y:s}}const l=getSide(i)==="left",o=max(...t.map(e=>e.right)),a=min(...t.map(e=>e.left)),n=t.filter(e=>l?e.left===a:e.right===o),s=n[0].top,r=n[n.length-1].bottom,e=a,c=o,d=c-e,u=r-s;return{top:s,bottom:r,left:e,right:c,width:d,height:u,x:e,y:s}}return u}const n=await a.getElementRects({reference:{getBoundingClientRect:f},floating:h.floating,strategy:m});return o.reference.x!==n.reference.x||o.reference.y!==n.reference.y||o.reference.width!==n.reference.width||o.reference.height!==n.reference.height?{reset:{rects:n}}:{}}}};async function convertValueToCoords(d,f){const{placement:t,platform:i,elements:m}=d,h=await(i.isRTL==null?void 0:i.isRTL(m.floating)),u=getSide(t),l=getAlignment(t),c=getMainAxisFromPlacement(t)==="x",o=["left","top"].includes(u)?-1:1,r=h&&c?-1:1,n=evaluate(f,d);let{mainAxis:a,crossAxis:e,alignmentAxis:s}=typeof n=="number"?{mainAxis:n,crossAxis:0,alignmentAxis:null}:{mainAxis:0,crossAxis:0,alignmentAxis:null,...n};return l&&typeof s=="number"&&(e=l==="end"?s*-1:s),c?{x:e*r,y:a*o}:{x:a*o,y:e*r}}const offset=function(e){return e===void 0&&(e=0),{name:"offset",options:e,async fn(n){const{x:s,y:o}=n,t=await convertValueToCoords(n,e);return{x:s+t.x,y:o+t.y,data:t}}}};function getCrossAxis(e){return e==="x"?"y":"x"}const shift=function(e){return e===void 0&&(e={}),{name:"shift",options:e,async fn(o){const{x:c,y:d,placement:m}=o,{mainAxis:h=!0,crossAxis:u=!1,limiter:f={fn:e=>{let{x:t,y:n}=e;return{x:t,y:n}}},...p}=evaluate(e,o),l={x:c,y:d},a=await detectOverflow(o,p),s=getMainAxisFromPlacement(getSide(m)),i=getCrossAxis(s);let n=l[s],t=l[i];if(h){const e=s==="y"?"top":"left",t=s==="y"?"bottom":"right",o=n+a[e],i=n-a[t];n=within(o,n,i)}if(u){const e=i==="y"?"top":"left",n=i==="y"?"bottom":"right",s=t+a[e],o=t-a[n];t=within(s,t,o)}const r=f.fn({...o,[s]:n,[i]:t});return{...r,data:{x:r.x-c,y:r.y-d}}}}},limitShift=function(e){return e===void 0&&(e={}),{options:e,fn(r){const{x:b,y:v,placement:u,rects:t,middlewareData:l}=r,{offset:g=0,mainAxis:p=!0,crossAxis:f=!0}=evaluate(e,r),h={x:b,y:v},n=getMainAxisFromPlacement(u),s=getCrossAxis(n);let i=h[n],o=h[s];const c=evaluate(g,r),a=typeof c=="number"?{mainAxis:c,crossAxis:0}:{mainAxis:0,crossAxis:0,...c};if(p){const e=n==="y"?"height":"width",s=t.reference[n]-t.floating[e]+a.mainAxis,o=t.reference[n]+t.reference[e]-a.mainAxis;i<s?i=s:i>o&&(i=o)}if(f){var d,m;const i=n==="y"?"width":"height",e=["top","left"].includes(getSide(u)),r=t.reference[s]-t.floating[i]+(e?((d=l.offset)==null?void 0:d[s])||0:0)+(e?0:a.crossAxis),c=t.reference[s]+t.reference[i]+(e?0:((m=l.offset)==null?void 0:m[s])||0)-(e?a.crossAxis:0);o<r?o=r:o>c&&(o=c)}return{[n]:i,[s]:o}}}},size=function(e){return e===void 0&&(e={}),{name:"size",options:e,async fn(n){const{placement:m,rects:w,platform:u,elements:p}=n,{apply:_=()=>{},...y}=evaluate(e,n),t=await detectOverflow(n,y),a=getSide(m),s=getAlignment(m),j=getMainAxisFromPlacement(m),v=j==="x",{width:o,height:i}=w.floating;let d,r;a==="top"||a==="bottom"?(d=a,r=s===(await(u.isRTL==null?void 0:u.isRTL(p.floating))?"start":"end")?"left":"right"):(r=a,d=s==="end"?"top":"bottom");const g=i-t[d],f=o-t[r],c=!n.middlewareData.shift;let l=g,h=f;if(v){const e=o-t.left-t.right;h=s||c?min(f,e):e}else{const e=i-t.top-t.bottom;l=s||c?min(g,e):e}if(c&&!s){const e=max(t.left,0),n=max(t.right,0),s=max(t.top,0),a=max(t.bottom,0);v?h=o-2*(e!==0||n!==0?e+n:max(t.left,t.right)):l=i-2*(s!==0||a!==0?s+a:max(t.top,t.bottom))}await _({...n,availableWidth:h,availableHeight:l});const b=await u.getDimensions(p.floating);return o!==b.width||i!==b.height?{reset:{rects:!0}}:{}}}};export{arrow,autoPlacement,computePosition,detectOverflow,flip,hide,inline,limitShift,offset,rectToClientRect,shift,size}